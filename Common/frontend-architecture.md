# 프론트엔드 아키텍쳐 & C4

## 1. 프론트엔드 아키텍처 설계란?

**프론트엔드 아키텍처 설계**는, 웹 애플리케이션(또는 웹 서비스)의 클라이언트 측을 **어떻게 구조화**하고 **어떤 기술**을 사용해 **확장성과 유지보수성**을 확보할지 결정하는 과정이다.  
단순히 "React/Vue/Angular"로 화면만 그리는 게 아니라, **라우팅**, **상태 관리**, **초기 로드 성능**, **빌드/배포 파이프라인**, **보안**, **모니터링** 등 전반적인 구조를 포함한다.

### 왜 필요한가?

1. **규모 확장**
   - 기능이 많아지고 팀 규모가 커질수록 복잡도가 높아져, 잘못된 구조는 유지보수에 큰 어려움을 초래.
2. **개발 효율**
   - 아키텍처를 미리 정의해두면, 요구사항 변화나 새로운 기술 도입 시 유연하게 대응 가능.
3. **성능 최적화**
   - 초기 로딩, 페이지 이동, 상호작용 속도 등은 사용자 경험에 직결되므로, 구조적 접근이 중요.

## 2. C4 모델의 개념

C4 모델은 **시스템**을 "큰 그림에서부터 코드 레벨까지" 점진적으로 시각화해 보여주는 다이어그램 방법론이다.

1. **레벨 1 (System Context)**

   - 우리 시스템이 사용자, 외부 시스템들과 어떻게 상호작용하는지 **전체 그림**을 보여줌.
   - 기술 비숙련자(PM, 디자이너, 경영진)와도 소통하기 쉬움.

2. **레벨 2 (Container)**

   - 웹 앱, 모바일 앱, 백엔드, DB 같은 **주요 컨테이너**로 나누어, 어떤 기술과 방식으로 연결되는지 표시.

3. **레벨 3 (Component)**

   - 컨테이너 내부를 **주요 컴포넌트(또는 '모듈')** 단위로 나눠서, 데이터 흐름과 의존관계를 표현.
   - 프론트엔드에서는 UI 컴포넌트와 혼동될 수 있으므로, 여기서는 "컴포넌트" 대신 "모듈"로 부르기도 함.

4. **레벨 4 (Code)**
   - 실제 코드(클래스, 함수, 폴더 구조, UI 컴포넌트 트리 등)를 상세히 표현.
   - 일반적으로는 큰 변경이나 복잡한 부분만 문서화.

## 3. 프론트엔드 아키텍처에서 C4 모델 활용

1. **레벨 1**

   - 예: 사용자(브라우저) ↔ 프론트엔드 SPA ↔ 백엔드 서버 ↔ 외부 API 식의 큰 흐름.

2. **레벨 2**

   - 예: React SPA, Express 서버, DB(MySQL), 외부 결제 API 등 컨테이너를 구분해 어떤 기술인지 명시.

3. **레벨 3**

   - 프론트엔드 내부를 **모듈**(대시보드, 설정, 로그인, 공통 UI 등) 단위로 표현.
   - 모듈 간 의존 관계나 데이터 흐름을 간단히 나타냄.

4. **레벨 4**
   - 한 모듈 내부를 **스크린(Screens)**, **기능(Features)**, **컴포넌트(Components)** 로 나누어 세부 코드 구조를 보여줌.

### 적용 시 주의사항

- **한 다이어그램에 너무 많은 정보**를 담지 말 것.
- **C4의 '컴포넌트'** 용어와 프론트엔드 'UI 컴포넌트' 용어가 혼동되지 않도록 주의('모듈'로 대체 권장).
- 텍스트 기반 다이어그램(PlantUML, Mermaid 등) + Git 관리로 협업하면 변경 이력 추적이 용이.

## 4. 예시: 간단한 이커머스 SPA 구조

- **레벨 1**: 사용자 → (React SPA) → (REST API) → (결제 서비스 API)
- **레벨 2**:
  - 컨테이너: React SPA / Node + Express / MySQL DB / 외부 결제
- **레벨 3**:
  - 모듈: `/shop`, `/cart`, `/checkout`, `/login`, 공통 UI
- **레벨 4**:
  - `Checkout 모듈` 내부를 `Screens`, `Features`, `UI 컴포넌트`로 세분화

## 5. 정리

- **프론트엔드 아키텍처 설계**: 프로젝트 초기에 "빌드/배포, 컴포넌트 구조, 상태관리, 보안, 모니터링" 등 전반을 고민해두면, 이후 확장과 유지보수가 훨씬 효율적이다.
- **C4 모델**을 활용하면, 이해관계자별로 필요한 수준의 정보를 제공하기 쉽고, 변화가 생길 때마다 다이어그램만 업데이트해도 **전체 시스템**을 빠르게 공유할 수 있다.

[참고]

- [Visualizing Frontend Architecture](https://frontendatscale.com/issues/17)
