# 자바스크립트 메모리구조

### 일반적인 프로세스 메모리 모델의 구조

![memory structure](../images/memory_structure_1.png)

**Text 영역**

- 프로그램 코드와 상수가 정의된 영역
- 읽기 전용으로 실행 시 수정할 수 없다.

**Data 영역**

- 전역 변수와 정적 변수가 저장된 영역
- 초기화된 데이터와 초기화되지 않은 데이터를 포함한다.

**Heap 영역**

- 동적 메모리 할당에 의해 사용되는 영역
- 런타임 시 크기가 변할 수 있으며 `malloc`, `new` 등의 함수로 관리된다.

**Stack 영역**

- 함수 호출 시 생성되는 지역 변수, 함수 매개변수, 반환 주소 등이 저장되는 영역
- LIFO(Last In, First Out) 방식으로 동작하며, 함수 종료 시 메모리가 해제된다.

**Node.js에서는 V8메모리 구조를 사용한다.**

### V8 엔진 메모리 구조

![memory structure V8](../images/memory_structure_2.png)

### 1. **힙 메모리 구조**

- **New 영역**
  - 새롭게 생성된 객체가 저장되는 영역으로, **짧은 생명주기를 가진 객체**가 위치한다.
  - 내부적으로 크기가 동일한 두 개의 하위 영역(**To 영역, From 영역**)으로 나뉜다.
    - **To 영역**: 대부분의 객체가 이곳에 생성
    - **From 영역**: 마이너 GC 후 살아남은 객체가 임시로 이동
- **Old 영역**
  - New 영역에서 여러 번의 GC를 거친 뒤 살아남은 객체가 이동하는 영역
  - 오래된 객체와 크기가 큰 객체가 저장된다
- **라지 오브젝트 영역**
  - 특정 크기 이상의 큰 객체가 저장되는 별도의 공간
- **코드 영역**
  - V8의 컴파일러가 생성한 실행 코드가 저장
- **셀, 속성 셀, 맵**
  - **Cells**: 각종 셀 구조를 포함
  - **PropertyCells**: 객체 속성 데이터 관리
  - **Maps**: 객체 레이아웃 정보를 저장

### **특징**

- GC 덕분에 힙 영역은 자동으로 관리되며, 메모리 누수를 방지할 수 있다
- 마이너 GC는 빠르고 자주 수행되며, 메이저 GC는 비교적 느리지만 대규모 메모리 관리에 사용된다

### 2. **가비지 컬렉션(GC)**

- GC는 의미 없는 메모리(사용되지 않는 객체)를 제거하여 **힙 메모리를 최적화**하는 역할을 한다
  ### **(1) 마이너 GC**
  - **New 영역**에서만 동작한다.
  - 새 객체를 위한 공간이 부족할 때 발생하며, 이 과정을 **스캐벤저(Scavenger)** 라고 한다.
  - New 영역이 가득 차면,
    - **To 영역**의 살아남은 객체가 **From 영역**으로 복사
    - 필요하지 않은 객체는 제거된다.
  ### **(2) 메이저 GC**
  - **Old 영역**을 관리한다.
  - Old 영역의 메모리가 부족하다고 판단될 때 발생하며, 상대적으로 실행 시간이 길다.
  - 메이저 GC는 다음 단계를 거친다.
    1. **객체 그래프 탐색**: 스택 포인터부터 시작해 객체 그래프를 순회하며 사용 중인 객체를 식별한다.
    2. **일시 정지**: 그래프 마킹의 마지막 단계에서 메인 스레드가 일시 정지된다.
    3. **병렬 압축**: 참조되지 않는 객체를 정리하고, 메모리 블록을 압축하여 단편화를 방지한다.

### 3. **메모리 단편화**

- **단편화**는 메모리 공간이 비효율적으로 사용되는 현상이다.
  - **내부 단편화**: 프로세스가 필요한 양보다 큰 메모리가 할당될 때 발생한다.
  - **외부 단편화**: 작은 빈 공간이 여러 개 존재해도, 큰 메모리를 할당할 수 없을 때 발생한다.

![memory fragmentation](../images/memory_structure_3.png)

### **해결 방법**

- **페이징**: 연속적인 메모리가 필요하지 않도록 메모리를 **페이지 단위**로 관리
- **세그멘테이션**: 메모리를 **서로 다른 크기의 세그먼트**로 나누어 관리
- **메모리 풀**: 미리 일정 크기의 메모리를 할당해두고 필요 시 재사용

### 4. **콜 스택과 메모리 힙의 특징**

- **콜 스택**
  - 함수 호출이 저장되는 LIFO(Last In, First Out) 구조
  - 메모리 할당 및 해제가 자동으로 수행됨
  - 처리 속도가 빠르며, 크기가 작고 **캐시 친화적**
  - 크기가 고정되어 있어 유연하지 않음
- **메모리 힙**
  - 객체와 동적 데이터가 저장되는 영역
  - 프로그래머가 메모리를 **수동으로 할당/해제**하거나 GC로 관리됨
  - 메모리가 전체적으로 분산되어 캐시 누락(Cache Miss)이 발생할 수 있음
  - 주요 문제는 **메모리 단편화**

### **자바스크립트 메모리 관리의 장점**

1. **자동 메모리 관리**: GC 덕분에 메모리 할당과 해제를 명시적으로 처리할 필요가 없다.
2. **효율적인 메모리 사용**: 콜 스택과 메모리 힙 구조를 통해 메모리를 체계적으로 관리한다.
3. **유연성**: GC가 메모리를 정리해주어 프로그래머는 로직 개발에 집중할 수 있다.

<br/>

[참고]

- [V8 엔진 내부의 메모리 관리 시각화 하기](https://ui.toast.com/weekly-pick/ko_20200228)

[이미지 출처]

- [V8 엔진 내부의 메모리 관리 시각화 하기](https://ui.toast.com/weekly-pick/ko_20200228)
- [콜스택, 메모리힙과 메모리모델 구조](https://supersfel.tistory.com/entry/%EC%BD%9C%EC%8A%A4%ED%83%9D-%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%9E%99%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%AA%A8%EB%8D%B8-%EA%B5%AC%EC%A1%B0)
