# JavaScript Question

- [touch vs click](#touch-vs-click)
- [mutable vs immutable](#mutable-vs-immutable)
- [debouncing vs throttling](#디바운싱과-쓰로틀링)
- [메모리 구조](#메모리-구조)
- [Promise](#promise)
- [콜 스택과 메모리 힙](#콜-스택과-메모리-힙)
- [import와 require의 차이점](#import와-require의-차이점)
- [Event Loop](#event-loop)
- [Call Apply Bind](#call-apply-bind)
- [Object, Set, Map](#set-object-map)
- []()

## touch vs click

> **touch 이벤트와 click 이벤트의 차이점에 대해 설명해주세요.**

touch 이벤트는 모바일 터치스크린에서 발생하고, 멀티터치를 지원하여 여러 포인터로 동시에 상호작용할 수 있습니다. 반면, click 이벤트는 주로 마우스 입력을 위한 것이며 단일 포인터만 사용합니다. 또한, 모바일에서 터치 후 click 이벤트가 약 300ms 지연되어 발생하는 특징이 있어, UI 반응 속도에 영향을 줄 수 있습니다.

## mutable vs immutable

> **불변성이 무엇이며, 불변성을 유지해야 하는 이유는 무엇인지 설명해주세요.**

불변성(immutability)은 데이터가 생성된 이후 변경되지 않는 성질을 말합니다. 특히 JavaScript에서는 원시 타입(Primitive)은 불변성을 가지지만, 참조 타입(Reference)은 기본적으로 가변성을 가집니다.

불변성을 유지해야 하는 이유는 다음과 같습니다

React는 상태 변경을 객체의 참조로 감지합니다. 참조 타입은 불변성을 유지하지 않으면 변경을 감지하지 못해 UI 업데이트가 실패할 수 있습니다. 또한 불변성을 유지하면 데이터 원본이 보호되어 부작용을 방지하고 디버깅이 쉬워집니다.

## 디바운싱과 쓰로틀링

> **디바운싱과 쓰로틀링의 차이점에 대해 설명해주세요.**

디바운싱과 쓰로틀링은 빈번하게 발생하는 이벤트를 최적화하는 기법입니다.<br/>
디바운싱은 빈번하게 발생하는 이벤트를 특정 시간 이후에 한 번만 실행시키고, 쓰로틀링은 빈번하게 발생하는 이벤트를 일정한 간격으로 한번만 실행한다는 점에서 차이가 있습니다.

> **디바운싱과 쓰로틀링은 어떤경우에 사용하게 되나요 실예시에 대해 설명해주세요.**

디바운싱은 주로 연이어 발생하는 이벤트를 단일 이벤트로 만들고 싶을 때 사용합니다. 빈번하게 발생하는 타이핑 이벤트의 결과 표시나, 블로그 글쓰기 에디터의 자동 저장 기능과 같은 상황에서 유용합니다.

쓰로틀링은 마지막 함수를 기다리지 않으며, 첫 번째 클릭에 의한 이벤트만을 실행하고 주어진 시간 동안 나머지는 무시하기 때문에 짧은 주기로 실행되는 이벤트를 조절하고 싶은 곳에 사용하는 것이 좋습니다. 예를 들면 하나의 버튼을 연속해서 누르는 경우에 타임아웃을 더 길게 설정하여 쓰로틀링을 적용하는 방법이 있습니다.

## 메모리 구조

> **콜 스택과 메모리 힙의 차이점은 무엇인가요?**

콜 스택은 함수 호출 시 생성되는 지역 변수, 함수 매개변수, 반환 주소 등이 저장되는 LIFO 구조입니다. 함수 종료시에는 메모리가 자동으로 해제됩니다. 그에 비해 메모리 힙은 객체와 동적 데이터가 저장되는 영역입니다. 콜 스택과는 달리 프로그래머가 메모리를 수동으로 할당/해제 해야합니다.

> **GC의 동작 방식과 한계에 대해 설명해주세요.**
> 가비지 콜렉터는 사용되지 않는 메모리를 제거하여 힙 메모리를 최적화하는 역할을 담당합니다.
> <br/>

- `minor GC`는 새 객체를 위한 공간이 부족할 때 발생하는데, new 영역이 가득차면 필요하지 않은 객체를 제거하는 방식으로 동작합니다. 이때 살아남은 객체들은 임시 저장됩니다.
- `major GC`는 old 영역의 메모리가 부족할 때 발생하며 **1) 사용중인 객체를 식별 2) 메인스레드 일시 정지 3) 참조되지 않는 객체 정리 및 메모리 블록 압축**의 단계로 진행됩니다.

GC는 메모리를 자동으로 관리해주지만, 메모리가 정확히 언제 해제될지는 알 수 없어서 세부적으로 제어하기 어렵습니다. 또한, GC가 실행되는 동안 애플리케이션의 다른 작업이 일시적으로 중단될 수 있어 성능 상의 오버헤드가 발생할 수 있습니다.

## Promise

> **Promise의 상태값에 대해 설명하고, 각 상태에서 어떤 작업이 이루어지는지 설명해주세요.**

Promise의 상태값은 크게 Pending , Fulfilled, Rejected 상태가 있습니다. Pending상태에서는 Promise 객체 생성 및 비동기 작업수행이 일어나며 Fulfilled 상태에서는 resolve()를 통해 결과값 전달 및 then() 핸들러 실행이 일어납니다. Rejected 상태에서는 reject()를 통해 에러 전달 및 catch()핸들러 실행이 일어납니다.

> **Promise 체이닝이 가능한 이유와, async/await과 Promise의 관계에 대해 설명해주세요.**

Promise 체이닝이 가능한 이유는 then() 메서드가 새로운 Promise 객체를 반환하기 때문입니다. 이를 통해 비동기 작업들을 순차적으로 처리하며 각 단계의 결과값을 다음 단계로 전달하게 됩니다.

async/await은 Promise를 기반으로 동작하는 문법적 개선안입니다. 모든 async 함수는 Promise를 반환하며, await 키워드는 Promise가 처리될 때까지 실행을 일시 중지시킵니다. 이를 통해 Promise 체이닝보다 더 직관적이고 동기적인 코드 스타일로 비동기 작업을 처리할 수 있습니다.

## 콜 스택과 메모리 힙

> **실행 컨텍스트에 대해 설명해주세요**

실행 컨텍스트는 코드가 실행될 때 만들어지는 환경입니다. 프로그램이 실행될 때 필요한 변수, 함수 호출, 스코프, this와 같은 정보들이 담깁니다.
먼저 함수가 호출되면 실행 컨텍스트가 생성되고, 콜스택에 쌓입니다. 함수 내에서 변수나 객체를 생성하면 int, float 등의 원시 자료형은 콜스택에, 객체나 배열 등 참조형 데이터는 힙 메모리에 저장됩니다. 함수 실행이 종료되면 콜스택에서 실행 컨텍스트가 제거되지만, 힙 메모리에 저장된 데이터는 GC가 동작하기 전까지 유지됩니다.

## import와 require의 차이점

> **브라우저에서 require를 사용하려면 어떤 방법을 사용해야 하나요?**

브라우저는 CommonJS를 지원하지 않기 때문에 Webpack 같은 번들러를 사용하거나 ES6 모듈로 전환하는 것이 일반적입니다.

> **ES6 모듈과 CommonJS 모듈의 성능 차이는 무엇인가요?**

ES6 모듈은 정적 분석 기반으로 동작하여 컴파일 타임에 모듈의 의존성을 미리 파악할 수 있습니다. 이를 통해 **트리 쉐이킹(Tree Shaking)**과 같은 최적화가 가능하며, 사용되지 않는 코드를 제거함으로써 번들 크기를 줄이고 성능을 향상시킬 수 있습니다. 이러한 특성은 특히 대규모 프로젝트에서 빛을 발합니다.

반면, CommonJS는 런타임 로딩 방식으로 동작하여 코드가 실행되는 시점에 모듈이 로드됩니다. 이로 인해 의존성 분석이 어렵고, 불필요한 코드까지 로드될 가능성이 있습니다. 따라서 성능 최적화 측면에서 ES6 모듈보다 제한적이며, 대규모 프로젝트에서는 비효율적일 수 있습니다.

## Event Loop

> **Event Loop에서 Microtask Queue와 Task Queue의 우선순위 차이를 설명하고, 그로 인해 발생할 수 있는 예시를 들어주세요.**

마이크로 태스크 큐의 작업은 일반 태스크 큐의 작업보다 우선순위가 높습니다. 이로인해 마이크로 태스크 큐에 들어가는 `.then()`보다 일반 태스크 큐에 들어있는 `callback` 함수가 더 나중에 실행됩니다.

> **JavaScript에서 비동기 작업이 완료되기까지의 과정을 간단히 설명해주세요.**

1. 각 함수가 실행되면 callstack이라는 공간에 push 되며 완료되면 pop된다.
2. callstack이 비동기 함수를 만나면 이를 background로 이관하여 실행한다.
3. background에서 비동기 함수의 실행이 완료되면 비동기 함수의 인자로 넘겨진 callback 함수는 event queue로 옮겨진다.
4. event loop는 callstack이 비어있는지 확인하고 있다가 callback 함수를 다시 callstack으로 옮긴다.
5. 옮겨진 callback 함수가 실행 완료되어 비동기 함수의 성공 또는 실패를 알린다.

## Call Apply Bind

> **call, apply, bind의 차이점에 대해 설명해주세요.**

call, apply, bind는 JavaScript에서 `this`를 명확하게 제어할 때 사용되는 메서드이다.

call, apply는 this에 바인딩할 객체를 첫번째 인자로 받아 즉시 실행한다. 다만, apply는 call과 다르게 인자를 배열로 전달해야 한다는 차이점이 있다. bind는 함수를 즉시 실행하지 않고 새로운 함수를 반환하기 때문에 `()`를 붙여 실행한다.

> **this 바인딩 문제를 해결하는 방법에는 어떤 것들이 있나요?**

1. `bind`, `call`, `apply` 메서드
2. 화살표 함수 사용

- 화살표 함수는 자신을 포함하는 스코프를 this로 기억한다.

```js
const obj = {
  name: "Yubin",
  greet: function () {
    const inner = () => {
      console.log(`Hello, ${this.name}`);
    };
    inner();
  },
};

obj.greet(); // "Hello, Yubin"
```

3. 변수에 this 저장하기

```js
const obj = {
  name: "Alice",
  greet: function () {
    const self = this; // this 저장
    function inner() {
      console.log(`Hello, ${self.name}`);
    }
    inner();
  },
};
```

> **실제 프로젝트에서 call이나 apply를 어떻게 활용할 수 있을지 설명해주세요.**

특정 객체의 메서드를 다른 객체에서도 사용하고 싶을 때 활용할 수 있습니다. 예를들어, logMessage 같은 공통적인 기능을 여러 객체에서 사용할 수 있습니다.

또한 기존 생성자의 로직을 그대로 활용하면서 새로운 객체를 생성하고 싶을 때 사용할 수 있습니다. 예를들어, Person 생성자를 Employee에서 재사용하여 중복 코드를 줄일 수 있습니다.

## Object, Set, Map

> **Map과 Object의 차이점을 한 가지 이상 설명해보세요. (예: 키의 타입, 삽입 순서 보장, 이터레이션 방식 등)**

Map과 Object는 모두 key-value 형태로 데이터를 저장하지만, Object는 key로 문자열과 심볼만 사용할 수 있는 반면, Map은 객체를 포함한 모든 타입을 key로 사용할 수 있습니다. Map은 삽입 순서를 보장하지만, Object는 순서를 보장하지 않습니다. Map은 이터레이션 시 `for...of`, `forEach` 방식을 사용하고 Object는 `for...in` 방식을 사용합니다.

> **Set을 사용할 때의 장점은 무엇이고, 어떤 상황에서 Set보다 Map이나 Object를 사용하는 것이 유리한지 말해보세요.**

Set은 중복 데이터를 자동으로 제거하므로 유일한 값들의 집합을 저장할 때 유용합니다. 또한 삽입 순서를 유지하고 빠른 순회를 지원한다는 장점을 갖습니다. 하지만 Set에는 key 개념이 없으므로 데이터를 `key-value` 형태로 저장하거나 특정 키로 빠르게 접근해야 할 경우에는 Object나 Map이 더 적합합니다.

## defer vs async

> **DomContentLoaded 함수에 대해서 설명해주세요.**

> **HTML에서의 스크립트 로딩 순서에 대해서 설명해주세요.**
