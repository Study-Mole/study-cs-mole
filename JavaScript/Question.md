# JavaScript Question

- [touch vs click](#touch-vs-click)
- [mutable vs immutable](#mutable-vs-immutable)
- [debouncing vs throttling](#디바운싱과-쓰로틀링)
- [메모리 구조](#메모리-구조)
- [Promise](#promise)
- [콜 스택과 메모리 힙](#콜-스택과-메모리-힙)

## touch vs click

> **touch 이벤트와 click 이벤트의 차이점에 대해 설명해주세요.**

touch 이벤트는 모바일 터치스크린에서 발생하고, 멀티터치를 지원하여 여러 포인터로 동시에 상호작용할 수 있습니다. 반면, click 이벤트는 주로 마우스 입력을 위한 것이며 단일 포인터만 사용합니다. 또한, 모바일에서 터치 후 click 이벤트가 약 300ms 지연되어 발생하는 특징이 있어, UI 반응 속도에 영향을 줄 수 있습니다.

## mutable vs immutable

> **불변성이 무엇이며, 불변성을 유지해야 하는 이유는 무엇인지 설명해주세요.**

불변성(immutability)은 데이터가 생성된 이후 변경되지 않는 성질을 말합니다. 특히 JavaScript에서는 원시 타입(Primitive)은 불변성을 가지지만, 참조 타입(Reference)은 기본적으로 가변성을 가집니다.

불변성을 유지해야 하는 이유는 다음과 같습니다

React는 상태 변경을 객체의 참조로 감지합니다. 참조 타입은 불변성을 유지하지 않으면 변경을 감지하지 못해 UI 업데이트가 실패할 수 있습니다. 또한 불변성을 유지하면 데이터 원본이 보호되어 부작용을 방지하고 디버깅이 쉬워집니다.

## 디바운싱과 쓰로틀링

> **디바운싱과 쓰로틀링의 차이점에 대해 설명해주세요.**

디바운싱과 쓰로틀링은 빈번하게 발생하는 이벤트를 최적화하는 기법입니다.<br/>
디바운싱은 빈번하게 발생하는 이벤트를 특정 시간 이후에 한 번만 실행시키고, 쓰로틀링은 빈번하게 발생하는 이벤트를 일정한 간격으로 한번만 실행한다는 점에서 차이가 있습니다.

> **디바운싱과 쓰로틀링은 어떤경우에 사용하게 되나요 실예시에 대해 설명해주세요.**

디바운싱은 주로 연이어 발생하는 이벤트를 단일 이벤트로 만들고 싶을 때 사용합니다. 빈번하게 발생하는 타이핑 이벤트의 결과 표시나, 블로그 글쓰기 에디터의 자동 저장 기능과 같은 상황에서 유용합니다.

쓰로틀링은 마지막 함수를 기다리지 않으며, 첫 번째 클릭에 의한 이벤트만을 실행하고 주어진 시간 동안 나머지는 무시하기 때문에 짧은 주기로 실행되는 이벤트를 조절하고 싶은 곳에 사용하는 것이 좋습니다. 예를 들면 하나의 버튼을 연속해서 누르는 경우에 타임아웃을 더 길게 설정하여 쓰로틀링을 적용하는 방법이 있습니다.

## 메모리 구조

> **콜 스택과 메모리 힙의 차이점은 무엇인가요?**

콜 스택은 함수 호출 시 생성되는 지역 변수, 함수 매개변수, 반환 주소 등이 저장되는 LIFO 구조입니다. 함수 종료시에는 메모리가 자동으로 해제됩니다. 그에 비해 메모리 힙은 객체와 동적 데이터가 저장되는 영역입니다. 콜 스택과는 달리 프로그래머가 메모리를 수동으로 할당/해제 해야합니다.

> **GC의 동작 방식과 한계에 대해 설명해주세요.**
> 가비지 콜렉터는 사용되지 않는 메모리를 제거하여 힙 메모리를 최적화하는 역할을 담당합니다.
> <br/>

- `minor GC`는 새 객체를 위한 공간이 부족할 때 발생하는데, new 영역이 가득차면 필요하지 않은 객체를 제거하는 방식으로 동작합니다. 이때 살아남은 객체들은 임시 저장됩니다.
- `major GC`는 old 영역의 메모리가 부족할 때 발생하며 **1) 사용중인 객체를 식별 2) 메인스레드 일시 정지 3) 참조되지 않는 객체 정리 및 메모리 블록 압축**의 단계로 진행됩니다.

GC는 메모리를 자동으로 관리해주지만, 메모리가 정확히 언제 해제될지는 알 수 없어서 세부적으로 제어하기 어렵습니다. 또한, GC가 실행되는 동안 애플리케이션의 다른 작업이 일시적으로 중단될 수 있어 성능 상의 오버헤드가 발생할 수 있습니다.

## Promise

> **Promise의 상태값에 대해 설명하고, 각 상태에서 어떤 작업이 이루어지는지 설명해주세요.**

Promise의 상태값은 크게 Pending , Fulfilled, Rejected 상태가 있습니다. Pending상태에서는 Promise 객체 생성 및 비동기 작업수행이 일어나며 Fulfilled 상태에서는 resolve()를 통해 결과값 전달 및 then() 핸들러 실행이 일어납니다. Rejected 상태에서는 reject()를 통해 에러 전달 및 catch()핸들러 실행이 일어납니다.

> **Promise 체이닝이 가능한 이유와, async/await과 Promise의 관계에 대해 설명해주세요.**

Promise 체이닝이 가능한 이유는 then() 메서드가 새로운 Promise 객체를 반환하기 때문입니다. 이를 통해 비동기 작업들을 순차적으로 처리하며 각 단계의 결과값을 다음 단계로 전달하게 됩니다.

async/await은 Promise를 기반으로 동작하는 문법적 개선안입니다. 모든 async 함수는 Promise를 반환하며, await 키워드는 Promise가 처리될 때까지 실행을 일시 중지시킵니다. 이를 통해 Promise 체이닝보다 더 직관적이고 동기적인 코드 스타일로 비동기 작업을 처리할 수 있습니다.

## 콜 스택과 메모리 힙

> **실행 컨텍스트에 대해 설명해주세요**

실행 컨텍스트는 코드가 실행될 때 만들어지는 환경입니다. 프로그램이 실행될 때 필요한 변수, 함수 호출, 스코프, this와 같은 정보들이 담깁니다.
먼저 함수가 호출되면 실행 컨텍스트가 생성되고, 콜스택에 쌓입니다. 함수 내에서 변수나 객체를 생성하면 int, float 등의 원시 자료형은 콜스택에, 객체나 배열 등 참조형 데이터는 힙 메모리에 저장됩니다. 함수 실행이 종료되면 콜스택에서 실행 컨텍스트가 제거되지만, 힙 메모리에 저장된 데이터는 GC가 동작하기 전까지 유지됩니다.
